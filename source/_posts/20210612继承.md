---
uuid: 26b87574-097d-7049-b91e-bc721e9d1908
title: 继承
layout: post
comments: true
toc: true
date: 2021-06-12 10:43:51
tags:
  - javascript 
  - 设计模式
  - 面向对象
categories: 
  - 前端
---

&emsp;&emsp;通过下面的代码块可以看到，每个类都有3个部分，第一部分是构造函数内的，这是供实例化对象复制用的，第二部分是构造函数外的，直接通过点语法添加的，这是供类使用的，实例化对象是访问不到的，第三部分是类的原型中的，实例化对象可以通过其原型链间接地访问到，也是为供所有实例化对象所共用的。

```javascript
var Book = function (title, time, author) {
  // 私有属性
  var num = 1
  // 私有方法
  function checkID() {
    console.log('check id');
  }
  // 构造函数内的，这是供实例化对象复制用的
  if (this instanceof Book) {
    // 公有属性
    this.title = title
    this.time = time
    this.author = author
    //特权方法
    /* 
      通过this创建的方法，不但可以访问这些对象
      的共有属性与共有方法，而且还能访问到类（创建时）
      或对象自身的私有属性和私有方法，由于这些方法
      权利比较大，所以我们又将它看作特权方法。 
    */
    this.getName = function () { }
    this.getPrice = function () { }

    //构造器
    /*
      在对象创建时通过使用这些特权方法我们可以初始化
      实例对象的一些属性，因此这些在创建对象时调用的
      特权方法还可以看作是类的构造器
    */
    this.setName = function () { }
    this.setPrice = function () { }
    //对象公有方法
    this.copy = function () { }
  } else {
    return new Book(title, time, author)
  }
}

// 构造函数外的，直接通过点语法添加的，这是供类使用的,实例化对象是访问不到的
// 类静态公有属性
Book.isChinese = true
// 类静态公有方法
Book.setItem = function (item) {
  console.log(item);
}

// 类的原型中的，实例化对象可以通过其原型链间接地访问到，也是为供所有实例化对象所共用的
Book.prototype = {
  // 公有属性
  isAboutJS: true,
  // 公有方法
  display: function () {
    console.log('book displayed');
  }
}

var book = Book('Javascript设计模式', '2000-01-01', 'ZRM')
console.log(book);                   // { title: 'Javascript设计模式', time: '2000-01-01', author: 'ZRM' }
console.log(book instanceof Book);   // true
console.log(book.isChinese);         // undefined
// book.setItem('js book')           // TypeError: book.setItem is not a function
Book.setItem('js book')              // js book
console.log(book.isAboutJS);         // true
console.log(Book.isAboutJS);         // undefined
book.display()                       // book displayed
// Book.display()                    // TypeError: Book.display is not a function
```

------

## 原型链和原型对象

&emsp;&emsp;  原型链和原型对象是`js`的核心，`js`以原型链的形式，保证函数或对象中的方法、属性可以向下传递。按照面向对象的说法，这就是继承。而`js`通过原型链才得以实现函数或对象的继承。

&emsp;&emsp;  每个构造函数都有一个原型对象`prototype`，原型有一个`constructor`属性指回构造函数，而实例有一个隐式原型属性`__proto__`指向原型。

### 原型链

#### 什么是原型链

&emsp;&emsp;  请看下面的代码：

```javascript
function Foo() {
  // 检察长:当没有使用new关键字初始化实例对象的时候,内部返回一个使用new关键字实例化的对象
  if (this instanceof Foo) {
    // 属性初始
  } else {
    return new Foo()
  }

  const obj = new Object()
  // -- Foo构造函数的原型对象
  console.log(Foo.prototype); //  Foo {}   
  //  -- 实例对象不存在显式原型属性
  console.log(this.prototype); // undefined  
  // -- 实例的隐士原型属性指向函数的显示原型属性
  console.log(this.__proto__); // Foo {}        
  console.log(Foo.prototype === this.__proto__); // true       
  // -- 原型对象的constructor属性指向构造函数
  console.log(Foo.prototype.constructor); // [Function: Foo]    
  console.log(Foo.prototype.constructor === Foo); // true       
  // -- Foo构造函数作为一个Function实例对象,他的隐式原型属性指向Function构造函数的原型对象
  console.log(Foo.__proto__); // [Function]                     
  console.log(Foo.__proto__ === Function.prototype); // true    
  // -- Function构造函数的原型对象的隐式原型属性,指向Object函数的原型对象
  console.log(Function.prototype.__proto__); // {}                        
  console.log(Function.prototype.__proto__===Object.prototype); // true   
  // -- Object实例对象的隐式原型属性指向Object构造函数的原型对象
  console.log(Object.prototype === obj.__proto__); // true                
  // -- Object作为Function构造函数创建的实例对象,他的隐式原型属性指向Function构造函数的原型对象
  console.log(Object.__proto__); // [Function]                      
  console.log(Object.__proto__ === Function.prototype); // true     
  // -- Object.prototype.__proto__原型链的尽头
  console.log(Object.prototype.__proto__); // null 
}

new Foo()
// Foo()
```

&emsp;&emsp;通过上面的代码可以看出以下的一个链式结构：

- 原型对象也称为函数的**显示原型属性**，只有函数才拥有该属性。
- 原型对象的`constructor`属性，指向原型对象的**构造函数**。
- 实例化函数对象的**隐式原型属性**，指向函数的**显示原型属性**。
- `Foo`构造函数作为一个`Function`构造函数的实例对象,他的隐式原型属性指向Function构造函数的原型对象。
- `Function`构造函数的原型对象的隐式原型属性,指向`Object`构造函数的原型对象。
- `Object`实例化对象`(obj)`的隐式原型属性指向`Object`构造函数的原型对象。
- `Object`作为`Function`构造函数创建的实例对象,他的隐式原型属性指向`Function`构造函数的原型对象。
- `Object.prototype.__proto__ = null`为原型链的尽头。

&emsp;&emsp;  这样形成的一个链式结构，称为**原型链**。

------

#### 原型链示意图

&emsp;&emsp;综合上述代码，可以画图以下的一个链式结构示意图。

![原型链示意图](/img/prototype.png)


------

## 继承

&emsp;&emsp;`ECMA-262` 把**原型链**定义为`ECMAScript` 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。



------

###  子类的原型对象——类式继承

&emsp;&emsp; **类式继承**的基本思想是：子类的原型对象`prototype`被赋予了父类的一个实例对象。

&emsp;&emsp; 我们实例化一个父类的时候，**父类的实例化对象**复制了父类的构造函数内的属性与方法并且将原型`__proto__`指向了**父类的原型对象**，这样就拥有了父类的原型对象上的属性与方法，并且这个**实例化对象**可直接访问到父类原型对象上的属性与方法。如果我们将这个**实例化对象**赋值给**子类的原型**，那么子类的原型就可以访问到父类的原型属性和方法。

&emsp;&emsp;而且**实例化对象**不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将**实例化对象**赋值给**子类的原型**，那么这个**子类的原型**同样可以访问**父类原型**上的属性和方法与从父类构造函数中复制的属性和方法。这正是**类式继承原理**。

&emsp;&emsp;如下代码所示：

```javascript
// 父类
function superClass() {
  this.superValue = true
}
// 共有方法
superClass.prototype.getsuperValue = function(){
  return this.superValue
}
// 子类
function subClass(){
  this.subValue = false
}
// 继承父类
subClass.prototype = new superClass()
// 为子类添加共有方法
subClass.prototype.getsubValue = function (){
  return this.subValue
}

var instance = new subClass()
console.log(instance.getsuperValue()) //true
console.log(instance.getsubValue()) // false

console.log(instance instanceof superClass) //true
console.log(instance instanceof subClass) //true
// subClass.prototype继承了superClass
console.log(subClass instanceof superClass) //false
console.log(subClass.prototype instanceof superClass) // true
```

------

#### 类式继承的缺点

- 由于子类通过其原型`prototype`指向**父类的实例化对象**，继承了父类。所以说**父类中的共有属性要是引用类型，就会在子类中被所有实例共用，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类**。

  ```javascript
  // 父类
  function superClass() {
    this.superValue = true
    this.car = {
      size:'2*4',
      color: 'blue',
      speed:'60km/h'
    }
  }
  // 共有方法
  superClass.prototype.getsuperValue = function(){
    return this.superValue
  }
  // 子类
  function subClass(){
    this.subValue = false
  }
  // 继承父类
  subClass.prototype = new superClass()
  // 为子类添加共有方法
  subClass.prototype.getsubValue = function (){
    return this.subValue
  }
  
  var instance1 = new subClass()
  var instance2 = new subClass()
  console.log(instance1.car) // { size: '2*4', color: 'blue', speed: '60km/h' }
  console.log(instance2.car) // { size: '2*4', color: 'blue', speed: '60km/h' }
  
  // 实例1改变了父类共有对象的属性值,实例2中共有对象属性值也会跟着改变
  instance1.car.size = '4*6'
  instance1.car.speed = "80km/h"
  console.log(instance1.car) // { size: '4*6', color: 'blue', speed: '80km/h' }
  console.log(instance2.car) // { size: '4*6', color: 'blue', speed: '80km/h' }
  ```

- 由于子类实现的继承是靠其原型 `prototype`指向父类的实例化对象实现的，因此**在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化**。

  ```javascript
  // 父类
  function superClass() {
    this.superValue = true
  }
  // 共有方法
  superClass.prototype.getsuperValue = function(){
    return this.superValue
  }
  // 子类
  function subClass(args){
    this.subValue = false
    this.args = args
  }
  // 继承父类
  subClass.prototype = new superClass()
  // 为子类添加共有方法
  subClass.prototype.getsubValue = function (){
    return this.subValue
  }
  
  var instance = new subClass('哈哈哈')
  console.log(instance.args); // 哈哈哈
  console.log(new superClass().args); // undefined
  ```

------

### 创建即继承——构造函数继承

&emsp;&emsp;如下代码所示：

```javascript
function superClass(id){
  // 引用类型共有属性
  this.books = ['Javascript', 'html', 'css']
  // 值类型共有属性
  this.id = id
}
// 父类声明原型方法
superClass.prototype.showBooks = function(){
  console.log(this.books)
}
// 声明子类
function subClass(id){
  // 继承父类
  superClass.call(this, id)
}
// 创建第一个子类的实例
var instance1 = new subClass(10)
// 创建第二个子类的实例
var instance2 = new subClass(11)
instance1.books.push("设计模式")
console.log(instance1.books)  // ["Javascript", "html", "css", "设计模式"]
console.log(instance1.id)     // 10
console.log(instance2.books)  // ["Javascript", "html", "css"]
console.log(instance2.id)     // 11
// instance1.showBooks()      // TypeError
```

&emsp;&emsp;`SuperClass.call(this, id)`这条语句是构造函数式继承的精华，由于`call`这个方法可以更改函数的作用环境，因此在子类中，对`superClass`调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。**由于这种类型的继承没有涉及原型 `prototype`，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则**。

------

### 将优点为我所用——组合继承

&emsp;&emsp;**类式继承**是**通过子类的原型`prototype`指向父类实例化对象来实现的**，**构造函数式继承**是**通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的**，所以只要在继承中同时做到这两点即可，即实现**组合继承**。

```javascript
function superClass(id){
  this.books = ['Javascript', 'html', 'css']
  this.id = id
}
// 父类声明原型方法
superClass.prototype.showBooks = function(){
  console.log(this.books)
}
// 构造函数继承
function subClass(id){
  // 继承父类
  superClass.call(this, id)
}
// 类式继承
subClass.prototype = new superClass()
// 子类实例化过程中又能将参数传递到父类的构造函数中
var instance1 = new subClass(10)
var instance2 = new subClass(11)
instance1.books.push("设计模式")
console.log(instance1.books)  // ["Javascript", "html", "css", "设计模式"]
console.log(instance1.id)     // 10
instance1.showBooks()         // ["Javascript", "html", "css", "设计模式"]

// instance1的books中添加书籍，不会影响父级的和子级其他实例对象的books对象属性
console.log(new subClass().books);  // [ 'Javascript', 'html', 'css' ]
console.log(instance2.books)        // ["Javascript", "html", "css"]
console.log(instance2.id)           // 11
```

&emsp;&emsp;子类的实例中更改父类继承下来的引用类型属性如`books`，根本不会影响到其他实例，并且子类实例化过程中又能将参数传递到父类的构造函数中。

&emsp;&emsp;在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍，所以这还不是最完美的方式。

------

### 洁净的继承者——原型式继承

&emsp;&emsp;借助原型`prototype`可以根据己有的对象创建一个新的对象，同时不必创建新的自定义对象类型。

```javascript
function inheritobject(obj){
  // 声明—个过渡函数对象
  function F(){}
  // 过渡对象的原型继承父对象
  F.prototype = obj
  // 返回过渡对象的—个实例，该实例的原型继承了父对象
  return new F()
}


var book = {
  name:"js book",
  alikeBook:["css book", "html book"]
}
var newBook = inheritobject(book)
newBook.name = "ajax book"
newBook.alikeBook.push("xml book")
var otherBook = inheritobject(book)
otherBook.name = "flash book"
otherBook.alikeBook.push("as book")
console.log(newBook.name)           //ajax book
console.log(newBook.alikeBook)      //["css book", "html book", "xml book","as book"]
console.log(otherBook.name)         //flash book
console.log(otherBook.alikeBook)    //["css book", "html book", "xml book","as book"]
console.log(book.name)              //js book
console.log(book.alikeBook)         //["css book", "html book", "xml book","as book"]
```

&emsp;&emsp;它是对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。

#### 优点:

&emsp;&emsp;这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便。

#### 缺点：

&emsp;&emsp;类式继承中的问题在这里也会出现。创建的新对象会影响到父类中的属性对象。

------

### 如虎添翼——寄生式继承

```javascript
function inheritobject(obj){
  // 声明—个过渡函数对象
  function F(){}
  // 过渡对象的原型继承父对象
  F.prototype = obj
  // 返回过渡对象的—个实例，该实例的原型继承了父对象
  return new F()
}

// 寄生式继承
// 声明基对象
var book = {
  name: "js book",
  alikeBook: ["css book", "html book"]
}
function createBook(obj){
  // 通过原型继承方式创建新对象
  var o = new inheritobject(obj)
  // 拓展新对象
  o.getName = function () {
    console.log(this.name)
  }
  o.setName = function(name){
    this.name = name
  }
  // 返回拓展后的新对象
  return o
}

let newBook = createBook(book)
newBook.getName()                 // js book
newBook.setName('java book')
newBook.getName()                 // java book
console.log(newBook.alikeBook);   // [ 'css book', 'html book' ]
newBook.alikeBook.push('js book')
// 也会更改父类的属性对象
console.log(newBook.alikeBook);   // [ 'css book', 'html book', 'js book' ]
console.log(book.alikeBook);      // [ 'css book', 'html book', 'js book' ]
```

&emsp;&emsp;寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法。寄生式继承这种增强新创建对象的继承思想也是寄托于原型继承模式。

------

### 终极继承者——寄生组合式继承

&emsp;&emsp;组合式继承，将类式继承同构造函数继承组合使用，但是这种方式有一个问题，就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承。

&emsp;&emsp;**寄生式继承**依托于**原型继承**与**构造函数继承**进行组合，形成**寄生组合式继承**。但是这里寄生式继承有些特殊，这里它处理的不是对象，而是类的原型。

```javascript
// 这里返回的是父类原型对象的一个副本
function inheritobject(obj) {
  // 声明一个过渡函数对象
  function F() { }
  // 过渡对象的原型继承父对象
  F.prototype = obj
  // 返回过渡对象的—个实例，该实例的原型继承了父对象
  return new F()
}
/*
  寄生式继承 继承原型
  传递参数 subClass 子类
  传递参数 superClass 父类 
*/
function inheritPrototype(subClass, superClass) {
  // 复制一份父类的原型副本保存在变量中
  var p = inheritobject(superClass.prototype)
  // 修正，因为重写子类原型导致子类的 constructor 属性被修改
  // 对复制对象 p 做一次增强，修复其 constructor 属性指向不正确的问题
  p.constructor = subClass
  // 设置子类的原型
  // 将得到的复制对象 p 赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数
  subClass.prototype = p
}

// 测试用例
// 上面的寄生式继承结合下面子类中的构造函数继承组成寄生组合式继承
// 定义父类
function superClass(name) {
  this.name = name
  this.colors = ["red", "blue", "green"]
}
// 定义父类原型方法
superClass.prototype.getName = function () {
  console.log(this.name)
}

// 定义子类
function subClass(name, time) {
  // 构造函数式继承
  superClass.call(this, name)
  // 子类新增属性
  this.time = time
}
// 寄生式继承父类原型
inheritPrototype(subClass, superClass)

// 子类新增原型方法
subClass.prototype.getTime = function () {
  console.log(this.time)
}
// 创建两个测试方法
var instance1 = new subClass("js book", 2014)
var instance2 = new subClass("css book", 2013)
console.log(instance1.colors);  // [ 'red', 'blue', 'green' ]
instance1.colors.push("black")
console.log(instance1.colors);  // [ 'red', 'blue', 'green', 'black' ] 
console.log(instance2.colors);  // [ 'red', 'blue', 'green' ]
console.log(instance1 instanceof subClass); // true
console.log(instance1 instanceof superClass); // true

instance1.getTime()  // 2014
instance1.getName()  // js book
instance2.getTime()  // 2013
instance2.getName()  // css book
```

&emsp;&emsp;组合式继承中，通过构造函数继承的属性和方法是没有问题的，所以这里主要探究**通过寄生式继承重新继承父类的原型**。**需要继承的仅仅是父类的原型，不再需要调用父类的构造函数**，换句话说:

1. **在构造函数继承中我们己经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们通过原型继承便可得到。**
2. **但是这么直接赋值给子类会有问题的，因为对父类原型对象复制得到的复制对象`p`中的`constructor`指向的不是`subClass`子类对象，因此在寄生式继承中要对复制对象`p`做一次增强，修复其`constructor`属性指向不正确的问题。**
3. **最后将得到的复制对象`p`赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数**。

&emsp;&emsp;这种方式继承如**下图**所示，其中**最大的改变就是对子类原型的处理，被赋予父类原型的一个引用**，这是一个对象，因此这里有一点要**注意，就是子类再想添加原型方法必须通过`prototype.`对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了**。

![寄生组合式继承原型链图片](/img/extends.jpg)

------

### 多继承

&emsp;&emsp;先看一个很流行的用来继承单对象属性的`extend`方法。

```javascript
var extend = function (target, source) {
  // 遍历源对象中的属性
  for (var property in source) {
    // 将源对象中的属性复制到目标对象中
    target[property] = source[property]superClass
  }
  // 返回目标对象
  return targetsuperClass
}
```

&emsp;&emsp;`extend`方法的实现就是对对象中的属性的一个复制过程，这个`extend`方法是一个浅复制过程，他只能复制值类型的属性，对于引用类型的属性它无能为力。而在`jquery`等一些框架中实现了深复制，就是将源对象中的引用类型的属性再执行一遍`extend`方法而实现的。

&emsp;&emsp;既然上面的方法可以实现对一个对象属性的复制继承，那么如果传递多个对象呢？

```javascript
// 多继承 属性复制
var mix = function () {
  var i = 1, // 从第二个参数起为被继承的对象
    len = arguments.length, // 获取参数长度
    target = arguments[0], // 第—个对象为目标对象
    arg // 缓存参数对象
  // 遍历被继承的对象
  for (i < len; i++) {
    // 缓存当前对象
    arg = arguments[i]
    // 遍历被继承对象中的属性
    for (var property in arg) {
      // 将被继承对象中的属性复制到目标对象中
      target[property] = arg[property]
    }
  }
  // 返回目标对象
  return target
}
```

&emsp;&emsp;`mix`方法的作用就是将传入的多个对象的属性复制到源对象中，这样即可实现对多个对象的属性的继承。也可以将它绑定到原生对象`Object`上，这样所有的对象就可以拥有这个方法。

```javascript
Object.prototype.mix = function () {
  var i = 0, // 从第—个参数起为被继承的对象
    len = arguments.length, // 获取参数长度
    arg // 缓存参数对象
  // 遍历被继承的对象
  for (; i < len; i++) {
    // 缓存当前对象
    arg = arguments[i]
    // 遍历被继承对象中的属性
    for (var property in arg) {
      // 将被继承对象中的属性复制到目标对象中
      this[property] = arg[property]
    }
  }
}
var book1 = {
  name: 'Javascript设计模式',
  alike: ['css', 'html', 'Javascript']
}
var book2 = {
  color: 'blue'
}
var otherBook = new Object()

otherBook.mix(book1, book2)
/*
  {
    name: 'Javascript设计模式',
    alike: [ 'css', 'html', 'Javascript' ],
    mix: [Function],
    color: 'blue'
  }
*/
console.log(otherBook)
```

------

## 总结

&emsp;&emsp;**继承即是对原有对象的封装**，从中创建私有属性、私有方法、特权方法、共有属性、共有方法等，对于每种属性与每种方法特点是不一样的，有的**不论对类如何实例化，它只创建一次，那么这类属性或者方法我们称之为静态的**。有的**只被类所拥有，那么这类属性和方法又是静态类方法与静态类属性**。当然可被继承的方法与属性无外乎两类，一类在构造函数中，这类属性与方法在对象实例化时被复制一遍。另一类在类的原型对象中，这类属性与方法在对象实例化时被所有实例化对象所共用。

&emsp;&emsp;提到类的实例化我们就引出了继承，当然如果实例化的是对象那么则为**对象继承**，如果实例化的是类（当然类也是一种对象，只不过是用来创建对象的），那么就是一种**类的继承**。对于**类的继承**我们根据继承的方式又分为很多种，**通过原型链继承的方式我们称之为类式继承，通过构造函数继承的方式我们称之为构造函数式继承，那么将这两种方式组合起来的继承方式我们称之为组合继承，由于类式继承过程中会实例化父类，这样如果父类构造函数极其复杂，那么这种方式对构造函数的开销是不值得的，此时有了一种新的继承方式，通过在一个函数内的过渡对象实现继承并返回新对象的方式我们称之为寄生式继承，此时我们在结合构造函数时继承，这样再融合构造函数继承中的优点并去除其缺点，得到的继承方式我们称之为寄生组合式继承。**

当然有时候**子类对父类实现继承可以通过拷贝方法与属性的方式来实现，这就有了多继承，即将多个父类（对象）的属性与方法拷贝给子类实现继承**。

