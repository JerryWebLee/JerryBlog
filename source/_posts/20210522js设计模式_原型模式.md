---
uuid: 38299696-bb87-07c7-df7e-e1e97826f6aa
title: JavaScript设计模式——原型设计模式
layout: post
comments: true
toc: true
date: 2021-05-22 00:21:20
tags:
  - javascript 
  - 设计模式
  - 面向对象
categories:
  - 前端
---

**所谓设计模式，是复现问题模型的思想的一种具体表现。一个问题模型可能有多种表达形式，但是如何将这类相似模型用代码的形式表现出来用以处理实际问题，这就产生了设计模式，设计模式是问题模型的具象化**。

javascript没有提供传统面向对象语言中类式继承,而是通过**原型委托**的方式来实现对象与对象之间的继承。

面向接口编程是设计模式中最重要的思想，但是在JavaScript中，面向接口编程的过程跟主流的静态类型语言不一样。

------



## 动态类型语言和静态类型语言

编程语言按照数据类型大体可以分为两类：**静态类型语言**和**动态类型语言**。

### 静态类型语言：

在编译时便已确定变量的类型。

#### 优点：

1. 编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序运行期间有可能发生的一些错误。
2. 在程序中明确地规定了数据类型，编译器还可以针对性的对程序进行优化，提高执行速度。

#### 缺点：

1. 迫使程序员依照强契约来编写程序。
2. 类型的声明增加更多代码，编程中这些细节会将程序员的经历从思考业务逻辑上分散开。

### 动态类型语言：

其变量类型要到程序运行时，待变量被赋予某个值后，才会具有某种类型。

#### 优点：

1. 代码量少，简洁，程序员可以将更多逻辑放在业务逻辑上面，专注逻辑表达，对阅读程序有帮助。

#### 缺点：

1. 无法保证变量的类型。

------



## 多态

同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。

多态背后的思想，是将“做什么”和“谁去做”以及“怎样去做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开。要实现这一点，归根结底要先消除类型之间的耦合关系。

多态性实际上指的是对象的多态性。

使用**继承**得到多态效果，继承一般包括实现继承和接口继承。

**多态的最根本作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句**

利用对象的多态性，不必考虑各个对象接到消息后应该做什么，对象应该做什么并不是临时决定的，而是事先已经约定好的，每个对象该做什么，已经成为了该对象的一个方法，被安装在对象内部，每个对象负责他们自己的行为。所以这些都想可以根据同一个消息有条不紊的分别执行自己的方法。

**将行为分布在各个对象种，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。**

------



## 封装

封装的目的是将数据隐藏，一般而言是封装数据和封装实现，更广义的封装，还包括封装类型和封装变化。

### 封装数据

在java种提供了 `private`，`public`，`protected`等关键字来提供不同的访问权限。但是JavaScript种没有该关键字，只能依赖于变量的作用域来实现封装特性，而且只能模拟出`private`，`public`两种封装性。

```javascript
var myObject = (function(){
  var _name = 'Jerry' // 私有变量
  return {
    getName:function(){  // 共有方法
      return _name
    }
  }
})()

console.log(myObject.getName()) // 输出：Jerry
console.log(myObject._name)     // 输出：undefined
```

### 封装实现

封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对他自己的行为负责。封装使得对象之间的耦合变得松散。对象之间只能通过对外的接口来通信。当我们修改一个对象时，可以随意的修改他的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。

### 封装类型

封装类型是**静态类型语言**种的一种重要的封装方式。

### 封装变化

**找到变化并封装之**

通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开，在系统演变的过程中，我们只需要替换那些容易变化的部分，如果这些是已经封装好的，替换起来也相对容易。可以最大程度的保证程序的稳定性和可扩展性。

------



## 原型模式和基于原型继承的JavaScript对象系统

在以类为中心的面向对象编程语言种，类和对象的关系可以 想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程思想种，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另一个对象所得到的。

原型不单是一种设计模式，也被称为一种编程泛型。

### 使用克隆的原型模式

从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。

原型模式实现的关键，是语言本身是否提供了clone方法，ES5提供了`Object.create()`方法，可以用来克隆对象，代码如下：

```javascript
var Plane = function () {
  this.blood = 100
  this.attackLevel = 1
  this.defenseLevel = 1
}

var plane = new Plane()
plane.blood = 500
plane.attackLevel = 10
plane.defenseLevel = 7

console.log(plane);
var clonePlane = Object.create(plane)
console.log(clonePlane.__proto__)


// 在不支持Object.create()方法的浏览器中，可以使用

Object.create = Object.create || function (obj) {
  var F = function () {
    F.prototype = obj
  }
  return new F()
}
```

### 克隆是创建对象的手段

原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。

JavaScript 就是使用原型模式来搭建整个面向对象系统的。在JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的JavaScript 对象都是从某个对象上克隆而来的。

### JavaScript中的原型继承

1. 所有的数据都是对象。
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
3. 对象会记住它的原型。
4. 如果对象无法响应某个请求，它会把这个请求沿着原型链继续查找。

JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆`Object.prototype` 对象，再进行一些其他额外操作的过程。

```javascript
function Person(name) {
  this.name = name
}

Person.prototype.getName = function () {
  return this.name
}
var person1 = new Person('Jerry')
var objectFactory = function () {
  var obj = new Object(),
    Constructor = [].shift.call(arguments) // 删除参数数组的第一个值赋值给Constructor
  // console.log(Constructor);
  obj.__proto__ = Constructor.prototype    // 指向正确的原型,把Person函数的getName()方法给obj
  var ret = Constructor.apply(obj, arguments)  // 借用外部传入的构造器给obj空对象设置name属性
  console.log(obj);  // Person { name: 'Jerry' }
  console.log(ret);  // undefined
  return typeof ret === 'object' ? ret : obj
}

var person2 = objectFactory(Person, 'Jerry')
console.log(person1);
console.log(person2);
```

ES6带来了新的语法Class。这让JavaScript看起来像是一门基于类的语言，但其背后仍是通过**原型机制**来创建对象。

